# 介绍
源自 MVC 设计模式，Qt 引入了模型/视图结构用于完成数据与界面的分离，即 InterView 框架。但不同的是，Qt 的 InterView 框架把视图和控制器部件结合在一起，使得框架更为简洁。

![](Qt.assets/Pasted%20image%2020220812144332.png)

Qt 的模型／视图结构分为三部分：模型(Model) 、视图(View)和代理(Delegate) 。其中，模型与数据源通信，并为其他部件提供接口；而视图从模型中获得用来引用数据条目的模型索引
(Model Index) 。在视图中，代理负责绘制数据条目，当编辑条目时，代理和模型直接进行通信。模型／视图／代理之间通过信号和槽进行通信，如图所示。关系如下：
+ 数据发生改变时，模型发出信号通知视图。
+ 用户对界面进行操作，视图发出信号。
+ 代理发出信号告知模型和视图编辑器目前的状态。

1. 模型
所有的模型都基于抽象基类 QAbstractItemModel 类，这个类定义了一个接口，可以供视图和委托来访问数据。数据本身并不一定要存储在模型中，也可以存储在一个数据结构、一个独立的类、文件、数据库或者应用程序的其他一些组件中。

QAbstractItemModel 为数据提供了一个十分灵活的接口来处理各种视图，这些视图可以将数据表现为表格 (table)、列表 (list) 和树 (tree) 等形式。要实现一个新的模型时，如果它基于列表或者表格的数据结构，可以使用 QAbstractListModel 和 QAbstractTableModel 类，因为它们为一些常见的功能提供了默认的实现。这些类都可以被子类化来提供模型，从而支持特殊类型的列表和表格。

Qt提供了一些现成的模型来处理数据项：
+ QStringListModel 用来存储一个简单的 QString 项目列表；
+ QStandardItemModel管理复杂的树型结构数据项，每一个数据项可以包含任
意的数据；
+ QFileSystemModel 提供了本地文件系统中文件和目录的信息；
+ QSqlQuery Model、QSqlTableModel和QSqlRelationalTableModel用来访问数据库。

如果Qt提供的这些标准模型无法满足需要，还可以子类化QAbstractItemModel、
QAbstractListModel 或者 QAbstractTableModel 来创建自定义的模型。

2. 视图
Qt 提供了几种不同类型的视图：QListView 将数据项显示为一个列表，QTableView 将模型中的数据显示在一个表格中，QTreeView 将模型的数据项显示在具有层次的列表中。这些类都基于 QAbstractItemView 抽象基类，这些类可以直接使用，也可以被子类化来提供定制的视图。
3. 委托
QAbstractItemDelegate 是委托的抽象基类。此类由 QlternDelegate 和 QStylediternDelegate 类继承。默认的委托实现由 QStyledItemDelegate 类提供。QStyledItemDelegate 和 QItemDelegate 是相互独立的，只能选择其一来为视图中的项目绘制和提供编辑器。它们的主要不同就是，QStyledItemDelegate 使用当前的样式来绘制项目，因此，当要实现自定义的委托或者要和 Qt 样式表一起应用时，建议使用 QStyledItemDelegate 作为基类。

# 模型类 （Model）

常见的3种模型分别是列表模型、表格模型和树模型

![](Qt.assets/Pasted%20image%2020220812155210.png)

## 模型索引

为了确保数据的表示与数据的获取相分离，Qt引入了模型索引的概念。每一块可以通过模型获取的数据都使用一个模型索引来表示，视图和委托都使用这些索引来请求数据项并显示。这样，只有模型需要知道怎样获取数据，被模型管理的数据类型可以广泛地被定义。模型索引包含一个指针，指向创建它们的模型，使用多个模型时可以避免混淆。

模型索引由QModelIndex类提供，它是对一块数据的临时引用，可以用来检索或者修改模型中的数据。因为模型可能随时对内部的结构进行重新组织，这样模型索引可能失效，所以不需要也不应该存储模型索引。如果需要对一块数据进行长时间的引用，则必须使用QPersistentModelIndex创建模型索引。

如果要获得一个数据项的模型索引，则必须指定模型的3个属性：行号、列号和父项的模型索引，例如：

```C++
QModelIndex index = model->index(row,column,parent);
```

## 行和列
一个模型可以通过把它看作一个简单的表格来访问，这时每个数据项可以使用行号和列号来定位。使用行号和列号只是一种约定，以确保各组件间可以相互通信。

行号和列号都是从0开始的，在图中可以看到，列表模型和表格模型的所有数据项都是以根项(Root item)为父项的，这些数据项都可以被称为顶层数据项(Top level item);在获取这些数据项的索引时，父项的模型索引可以用QModelIndex()表示。例如，图中的Table Model中的A、B、C这3项的模型索引可以用如下代码
获取：

```c++
QModelIndex indexA = model->index(0,0,QModelIndex());
QModelIndex indexB = model->index(1,1,QModelIndex());
QModelIndex indexC = model->index(2,1,QModelIndex());
```

## 父项
前面讲述的类似于表格的接口对于在使用表格或者列表时是非常理想的，但是，像树视图一样的结构需要模型提供一个更加灵活的接口，因为每一个数据项都可能成为其他数据项表格的父项，一个树视图中的顶层数据项也可能包含其他的数据项列表。

当为模型项请求一个索引时，就必须提供该数据项父项的一些信息。顶层数据项可以使用QModelIndex()作为父项索引，但是在树模型中，如果一个数据项不是顶层数据项，那么就要指定它的父项索引。例如，图中的树模型（Tree Model）中的A、B、C项的模型索引可以使用如下代码获得：

```cpp
QModelIndex indexA = model->index(0,0,QModelIndex());
QModelIndex indexC = model->index(2,0,QModelIndex());
QModelIndex indexB = model->index(1,0,indexA);
```

## 项角色
模型中的数据项可以作为各种角色在其他组件中使用，允许为不同的情况提供不同类型的数据。

例如，Qt::DisplayRole用于访问一个字符串，所以可以作为文本显示在视图中。通常情况下，数据项包含了一些不同角色的数据，这些标准的角色由枚举类型Qt::ItemDataRole来定义，常用的角色如表:


| 常量                  | 描述                       |
| --------------------- | -------------------------- |
| Qt::DisplayRole       | 显示文字                   |
| Qt::DecorationRole    | 绘制装饰数据（通常是图标） |
| Qt::EditRole          | 在编辑器中编辑的数据       |
| Qt:ToolTipRole        | 工具提示                   |
| Qt::StatusTipRole     | 状态栏提示                 |
| Qt:WhatsThisRole      | What's This文字            |
| Qt::SizeHintRole      | 尺寸提示                   |
| Qt::FontRole          | 默认代理的绘制使用的字体   |
| Qt::TextAlignmentRole | 默认代理的对齐方式         |
| Qt::BackgroundRole    | 默认代理的背景画刷         |
| Qt::ForegroundRole | 默认代理的前景画刷        |
| Qt::CheckStateRole | 默认代理的检查框状态        |
| Qt::UserRole | 用户自定义的数据的起始位置        |

通过为每个角色提供适当的项目数据，模型可以为视图和委托提供提示，告知数据应该怎样展示给用户。角色指出了从模型中引用哪种类型的数据，视图可以使用不同的方式来显示不同的角色，不同类型的视图也可以自由地解析或者忽略这些角色信息。

可以通过向模型指定相关数据项对应的模型索引以及特定的角色来获取需要的类型的数据，例如：

```cpp
QVariant value = model->data(index,role);
```

